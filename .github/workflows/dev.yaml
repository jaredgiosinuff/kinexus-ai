# Kinexus AI - AWS Deployment Workflow
# Deploys to AWS using CDK with Docker images for production environments

name: Deploy to AWS

on:
  push:
    branches:
      - main
      - develop
      - 'release/**'
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/**'
      - '!.github/workflows/dev.yaml'
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      deployment_type:
        description: 'Deployment type'
        required: true
        type: choice
        options:
          - mvp
          - production
        default: 'production'
      skip_tests:
        description: 'Skip tests'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  POETRY_VERSION: '1.7.1'

permissions:
  id-token: write   # Required for OIDC authentication
  contents: read
  pull-requests: write

jobs:
  # Determine deployment configuration
  configure:
    name: Configure Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      deployment_type: ${{ steps.config.outputs.deployment_type }}
      should_deploy: ${{ steps.config.outputs.should_deploy }}
      ecr_repository: ${{ steps.config.outputs.ecr_repository }}

    steps:
      - name: Determine deployment configuration
        id: config
        run: |
          # Determine environment based on branch/input
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            DEPLOYMENT_TYPE="${{ github.event.inputs.deployment_type }}"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="production"
            DEPLOYMENT_TYPE="production"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            ENVIRONMENT="development"
            DEPLOYMENT_TYPE="mvp"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
            ENVIRONMENT="staging"
            DEPLOYMENT_TYPE="production"
            SHOULD_DEPLOY="true"
          else
            ENVIRONMENT="development"
            DEPLOYMENT_TYPE="mvp"
            SHOULD_DEPLOY="false"  # Only validate PRs
          fi

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "deployment_type=$DEPLOYMENT_TYPE" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "ecr_repository=kinexus-ai" >> $GITHUB_OUTPUT

          echo "üìã Configuration:"
          echo "  Environment: $ENVIRONMENT"
          echo "  Deployment Type: $DEPLOYMENT_TYPE"
          echo "  Should Deploy: $SHOULD_DEPLOY"

  # Run tests and code quality checks
  test:
    name: Test & Quality Checks
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != 'true' }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: kinexus_user
          POSTGRES_PASSWORD: kinexus_pass
          POSTGRES_DB: kinexus_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache Poetry dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pypoetry
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Install dependencies
        run: |
          poetry install --with dev

      - name: Run linting
        run: |
          poetry run black --check src/ tests/
          poetry run isort --check-only src/ tests/
          # TODO: Fix ruff violations and re-enable
          # poetry run ruff src/ tests/

      - name: Run type checking
        run: |
          # TODO: Fix mypy errors and re-enable
          # poetry run mypy src/
          echo "‚ö†Ô∏è Type checking temporarily disabled"

      - name: Run security scan
        run: |
          poetry run bandit -r src/ -ll

      - name: Run tests with coverage
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_NAME: kinexus_test
          DB_USER: kinexus_user
          DB_PASSWORD: kinexus_pass
          REDIS_URL: redis://localhost:6379/0
          ENVIRONMENT: test
        run: |
          poetry run pytest tests/ \
            --cov=src \
            --cov-report=term-missing \
            --cov-report=xml \
            --junitxml=pytest-results.xml

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
          flags: unittests
          name: codecov-umbrella

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results
          path: pytest-results.xml

  # Build Docker images for production deployments
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [configure, test]
    if: needs.configure.outputs.deployment_type == 'production' && (needs.configure.outputs.should_deploy == 'true' || github.event_name == 'pull_request')

    strategy:
      matrix:
        service:
          - name: api
            dockerfile: docker/Dockerfile.api.prod
            context: .
          - name: orchestrator
            dockerfile: docker/Dockerfile.orchestrator.prod
            context: .
          - name: change-analyzer
            dockerfile: docker/Dockerfile.change-analyzer.prod
            context: .
          - name: content-creator
            dockerfile: docker/Dockerfile.content-creator.prod
            context: .
          - name: quality-controller
            dockerfile: docker/Dockerfile.quality-controller.prod
            context: .
          - name: web-automator
            dockerfile: docker/Dockerfile.web-automator.prod
            context: .

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ needs.configure.outputs.ecr_repository }}-${{ matrix.service.name }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: ${{ needs.configure.outputs.should_deploy == 'true' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Output image digest
        run: echo ${{ steps.docker_build.outputs.digest }}

  # Build Lambda layer for MVP deployments
  build-lambda-layer:
    name: Build Lambda Layer
    runs-on: ubuntu-latest
    needs: [configure, test]
    if: needs.configure.outputs.deployment_type == 'mvp' && needs.configure.outputs.should_deploy == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Build Lambda layer
        run: |
          ./scripts/build-layer.sh

      - name: Upload Lambda layer artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-layer
          path: lambda_layer.zip
          retention-days: 1

  # Deploy infrastructure using CDK
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: [configure, test, build, build-lambda-layer]
    if: |
      always() &&
      needs.configure.outputs.should_deploy == 'true' &&
      (needs.build.result == 'success' || needs.build.result == 'skipped') &&
      (needs.build-lambda-layer.result == 'success' || needs.build-lambda-layer.result == 'skipped') &&
      needs.test.result == 'success'

    environment:
      name: ${{ needs.configure.outputs.environment }}
      url: ${{ steps.deploy.outputs.endpoint_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Lambda layer (if MVP)
        if: needs.configure.outputs.deployment_type == 'mvp'
        uses: actions/download-artifact@v4
        with:
          name: lambda-layer
          path: .

      - name: Install CDK dependencies
        run: |
          npm install -g aws-cdk
          pip install -r infrastructure/requirements.txt

      - name: CDK Bootstrap (if needed)
        run: |
          cdk bootstrap \
            -c deployment_type=${{ needs.configure.outputs.deployment_type }} \
            -c environment=${{ needs.configure.outputs.environment }} \
            -c region=${{ env.AWS_REGION }} \
            -c account=${{ secrets.AWS_ACCOUNT_ID }}

      - name: CDK Synth
        run: |
          cdk synth \
            -c deployment_type=${{ needs.configure.outputs.deployment_type }} \
            -c environment=${{ needs.configure.outputs.environment }} \
            -c region=${{ env.AWS_REGION }} \
            -c account=${{ secrets.AWS_ACCOUNT_ID }}

      - name: CDK Deploy
        id: deploy
        run: |
          cdk deploy \
            -c deployment_type=${{ needs.configure.outputs.deployment_type }} \
            -c environment=${{ needs.configure.outputs.environment }} \
            -c region=${{ env.AWS_REGION }} \
            -c account=${{ secrets.AWS_ACCOUNT_ID }} \
            --require-approval never \
            --outputs-file cdk-outputs.json

          # Extract outputs
          if [ -f cdk-outputs.json ]; then
            API_ENDPOINT=$(jq -r '.[] | .APIEndpoint // .LoadBalancerDNS // empty' cdk-outputs.json | head -n1)
            echo "endpoint_url=$API_ENDPOINT" >> $GITHUB_OUTPUT
          fi

      - name: Upload CDK outputs
        uses: actions/upload-artifact@v4
        with:
          name: cdk-outputs
          path: cdk-outputs.json
          retention-days: 30

      - name: Run database migrations
        if: needs.configure.outputs.deployment_type == 'production'
        run: |
          # Run migrations via ECS task or Lambda
          echo "Running database migrations..."
          # aws ecs run-task ... or aws lambda invoke ...
          # This depends on your migration strategy

      - name: Run health check
        run: |
          if [ -n "${{ steps.deploy.outputs.endpoint_url }}" ]; then
            echo "Waiting for deployment to be healthy..."
            sleep 30

            for i in {1..10}; do
              if curl -f -s "${{ steps.deploy.outputs.endpoint_url }}/health" > /dev/null 2>&1; then
                echo "‚úÖ Deployment is healthy!"
                exit 0
              fi
              echo "Attempt $i/10: Health check failed, retrying..."
              sleep 10
            done

            echo "‚ùå Health check failed after 10 attempts"
            exit 1
          else
            echo "‚ö†Ô∏è  No endpoint URL available, skipping health check"
          fi

  # Post-deployment validation
  validate:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: [configure, deploy]
    if: needs.deploy.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download CDK outputs
        uses: actions/download-artifact@v4
        with:
          name: cdk-outputs
          path: .

      - name: Run smoke tests
        run: |
          echo "Running smoke tests against deployment..."
          # Add your smoke tests here
          # Example:
          # poetry run pytest tests/smoke/ --base-url="${{ needs.deploy.outputs.endpoint_url }}"

      - name: Notify deployment success
        if: success()
        run: |
          echo "üéâ Deployment to ${{ needs.configure.outputs.environment }} completed successfully!"

  # Comment on PR with deployment details
  comment-pr:
    name: Comment on PR
    runs-on: ubuntu-latest
    needs: [configure, deploy, validate]
    if: github.event_name == 'pull_request' && needs.deploy.result == 'success'

    steps:
      - name: Download CDK outputs
        uses: actions/download-artifact@v4
        with:
          name: cdk-outputs
          path: .

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const outputs = JSON.parse(fs.readFileSync('cdk-outputs.json', 'utf8'));

            let outputsMarkdown = '### CloudFormation Outputs\n\n';
            for (const [key, value] of Object.entries(outputs)) {
              outputsMarkdown += `**${key}**\n\`\`\`\n${JSON.stringify(value, null, 2)}\n\`\`\`\n\n`;
            }

            const comment = `## üöÄ AWS Deployment Preview

            **Environment**: \`${{ needs.configure.outputs.environment }}\`
            **Deployment Type**: \`${{ needs.configure.outputs.deployment_type }}\`
            **Region**: \`${{ env.AWS_REGION }}\`

            ${outputsMarkdown}

            ### Services Deployed:
            ${{ needs.configure.outputs.deployment_type == 'production' && '- ‚úÖ ECS Fargate Cluster\n- ‚úÖ RDS PostgreSQL\n- ‚úÖ ElastiCache Redis\n- ‚úÖ Application Load Balancer\n- ‚úÖ Cognito User Pool\n- ‚úÖ CloudWatch Monitoring' || '- ‚úÖ Lambda Functions\n- ‚úÖ DynamoDB Tables\n- ‚úÖ API Gateway\n- ‚úÖ EventBridge\n- ‚úÖ S3 Buckets' }}

            ### üîó Quick Links:
            - **API Health**: Check \`/health\` endpoint
            - **API Docs**: Check \`/docs\` endpoint
            - **CloudWatch Logs**: [View in AWS Console](https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }})

            ---
            *Deployed via GitHub Actions*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Cleanup on failure
  cleanup-on-failure:
    name: Cleanup Failed Deployment
    runs-on: ubuntu-latest
    needs: [configure, deploy]
    if: failure() && needs.deploy.result == 'failure' && needs.configure.outputs.environment != 'production'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback deployment
        run: |
          echo "‚ö†Ô∏è  Deployment failed, considering rollback..."
          # Add rollback logic if needed
          # For non-production environments, you might want to destroy the stack
          # cdk destroy --force
